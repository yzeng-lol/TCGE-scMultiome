---
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    theme: cerulean
params:
  ## will be override by render
  readin: "Sample.RDS"
  sample_id: "Sample"
---

This report is generated by the [iSHARC](https://github.com/yzeng-lol/iSHARC).
For more modularized downstream analyses, please refer to [COBE](https://www.pmcobe.ca/pipeline/618285d473c8c4003964393b).

```{r setup, include=FALSE}
##knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
## read in scMultiome.RDS
scMultiome <- readRDS(params$readin)
sample_id <- params$sample_id
```

---
title: "`r sample_id`_scMultiome_QC_and_Primary_Results"
---

```{r include=FALSE}
## loading packages without showing
library(Seurat)
library(Signac)
library(dplyr)
library(ggplot2)
library(plotly)
library(knitr)
library(SingleR)       ## auto annotation
library(celldex)       ## annotation reference
#library(heatmaply)
#library(gapminder)
#library(gplots)
```

## QC metrics and filtering
### Selected Percentiles for QC metrics
* nCount_RNA: Number of transcripts detected per cell
* percent.mt: Percentage of reads originating from the mitochondrial genes
* nCount_ATAC: The number of unique nuclear fragments
* TSS.enrichment: The ratio of fragments centered at the TSS to fragments in TSS-flanking regions
* nucleosome_signal: Approximate ratio of mononucleosomal to nucleosome-free fragments

```{r echo = FALSE}
## display selected metrics

qc_df <- data.matrix(scMultiome [[c("nCount_RNA","percent.mt", "nCount_ATAC", "TSS.enrichment", "nucleosome_signal")]])
probs_s <- c(0, 0.025, 0.25, 0.50, 0.75, 0.975, 1)
qc_percentiles <- apply(qc_df, 2, function(x) quantile(x, probs = probs_s, na.rm = TRUE))

#rownames(sum_adj) <- c("", "Q1", "Median", "Mean", "Q3", "Max")
ti <- paste("Number of joint called cells by Cellranger-ARC: ", ncol(scMultiome))
kable(qc_percentiles, caption = ti)
```

### Violin plots for selected QC metrics
```{r  echo = FALSE, fig.width = 13}
VlnPlot(scMultiome, features = c("nCount_RNA","percent.mt", "nCount_ATAC", "TSS.enrichment", "nucleosome_signal"), ncol = 5, log = TRUE, pt.size = 0, group.by = "orig.ident") + NoLegend()
```

### Second round filtering before integration
* Second round QC metrics cutoffs are determined based on the suggested cut-offs and corresponding 2.5/97.5th percentiles as below:
* nCount_RNA:  [max(1000, 2.5th percentile), min(25000, 97.5th percentile)]
* percent.mt:  min(20, 97.5th percentile)
* nCount_ATAC: [max(5000, 2.5th percentile), min(70000, 97.5th percentile)]
* TSS.enrichment: max(1, 2.5th percentile)
* nucleosome_signal: min(2, 97.5th percentile)

```{r echo = FALSE}
## display selected metrics
qc_df <- data.frame(qc_df)
qc_percentiles  <- data.frame(qc_percentiles)

idx_RNA <- qc_df$nCount_RNA > max(1000, qc_percentiles$nCount_RNA[2]) &
           qc_df$nCount_RNA < min(25000, qc_percentiles$nCount_RNA[6])
idx_mt <- qc_df$percent.mt < min(20, qc_percentiles$percent.mt[6])
idx_ATAC <- qc_df$nCount_ATAC > max(5000, qc_percentiles$nCount_ATAC[2]) &
            qc_df$nCount_ATAC < min(70000, qc_percentiles$nCount_ATAC[6])  
idx_tss <- qc_df$TSS.enrichment > max(1, qc_percentiles$TSS.enrichment[2])
idx_ns <- qc_df$nucleosome_signal < min(2, qc_percentiles$nucleosome_signal[6])

cnt_RNA <- sum(idx_RNA & idx_mt, na.rm = T)
cnt_ATAC <- sum(idx_ATAC & idx_mt & idx_tss & idx_ns, na.rm = T)
cnt_both <- sum(idx_RNA & idx_ATAC & idx_mt & idx_tss & idx_ns, na.rm = T)

cells_2filtered <- data.frame(cnt_RNA, cnt_ATAC, cnt_both)
cells_frac <- round(cells_2filtered / nrow(qc_df), 2)
cells_2filtered  <- rbind(cells_2filtered, cells_frac)

rownames(cells_2filtered) <- c("Number of cells", "Fraction of 1st filtered cells")
colnames(cells_2filtered) <- c("2nd_filtered_by_RNA", "2nd_filtered_by_ATAC",        "2nd_filtered_by_Both")
kable(cells_2filtered)
```


## Cell cycle assessment
* Be cautious when dealing with cells undergoing differentiation processes (like [hematopoiesis](https://satijalab.org/seurat/articles/cell_cycle_vignette.html#alternate-workflow)).
* PCA plots before and after regressing out the effects of cell cycle, only cell cycle genes are used for PCA analysis.
```{r, echo=FALSE, message = FALSE, warning = FALSE, fig.width = 15, fig.height= 5}
## bar plot for the number of cells per cell cycle status

cc_cnt <- table(scMultiome$Phase)
cc_pct <- paste(round(100 * cc_cnt/sum(cc_cnt), 2), "%", sep="")
cc_group <- factor(names(cc_cnt), levels = c("G1", "S", "G2M", "Undecided"))


dat <- data.frame(cc_cnt, cc_pct, cc_group)

p1 <- ggplot(dat, aes(y = cc_cnt, x = cc_group, fill = cc_group)) + geom_bar(stat='identity')
p1 <- p1 + geom_text(aes(label = cc_cnt), size = 5, vjust =  1.5)
p1 <- p1 + geom_text(aes(label = cc_pct), size = 5, vjust = -0.2)
p1 <- p1 + labs(y = "Number of cells", x = "Cell cycle phases")
p1 <- p1 + theme_classic() +   theme(legend.position = "none")


## PCA plots before and after regressing out the cell cycle effects
## cell cycle genes
s.genes <- cc.genes$s.genes
g2m.genes <- cc.genes$g2m.genes

## without regressing out cell cycle
cc_ori <- SCTransform(
    scMultiome,
    assay = 'RNA',
    new.assay.name = 'SCT_cc',
    vars.to.regress = c('percent.mt'), #, 'nFeature_RNA', 'nCount_RNA')
    verbose = F    ## doesn't print out the progress bars
    )
cc_ori <- RunPCA(cc_ori, features = c(s.genes, g2m.genes))
p2 <- DimPlot(cc_ori, group.by = "Phase") + ggtitle("Before")

## regressing out cell cycle
DefaultAssay(scMultiome) <- "SCT"   ## which has regressed out cell cycle by default
cc_reg <- RunPCA(scMultiome, features = c(s.genes, g2m.genes))
p3 <- DimPlot(cc_reg, reduction = "pca", group.by = "Phase") + ggtitle("After")

## combine figures for output
p1 + p2 + p3  & theme(plot.title = element_text(hjust = 0.5))

```

## Clustering results
### Based on RNA, ATAC alone and WNN integrated
```{r, echo=FALSE, fig.width = 15, fig.height= 5}
p1 <- DimPlot(scMultiome, reduction = "umap.rna",  group.by = "SCT_snn_res.0.8", label = TRUE, label.size = 2.5, repel = TRUE) + ggtitle("RNA")
p2 <- DimPlot(scMultiome, reduction = "umap.atac", group.by = "ATAC_snn_res.0.8", label = TRUE, label.size = 2.5, repel = TRUE) + ggtitle("ATAC")
p3 <- DimPlot(scMultiome, reduction = "wnn.umap", group.by = "wsnn_res.0.8",  label = TRUE, label.size = 2.5, repel = TRUE) + ggtitle("WNN")

p1 + p2 + p3  & theme(plot.title = element_text(hjust = 0.5))

```

### Modality weights for integrated clustering
The modality weights for each of the cell populations. Higher RNA weights indicate the transcriptomic markers contribute more in distinguishing between different cell populations, Likewise, higher ATAC weights represent the epigenomic markers contribute more in distinguishing between different cell populations.

```{r, echo=FALSE, fig.width = 15, fig.height= 3}

VlnPlot(scMultiome, features = "SCT.weight", group.by = 'wsnn_res.0.8', sort = FALSE, pt.size = 0.1) + ggtitle("RNA weights")

VlnPlot(scMultiome, features = "ATAC.weight", group.by = 'wsnn_res.0.8', sort = FALSE, pt.size = 0.1) +  ggtitle("ATAC weights")
```

## Auto annotation
### Per integrated clusters annotation based on publicly avalialbe references
The Blueprint/ENCODE reference from R package [celldex](https://bioconductor.org/packages/3.17/data/experiment/vignettes/celldex/inst/doc/userguide.html) is used for automatic annotation.

```{r, echo=FALSE, message = FALSE, warning = FALSE, fig.width = 15, fig.height= 6}
## just in case the scMultiome.RDS didn't automatic annotated
if(is.na(match("WNN_SingleR_anno", colnames(scMultiome@meta.data)))){

## BlueprintEncodeData requires internet to download corresponding data
# anno_ref <-  BlueprintEncodeData()       ## form package celldex

## pre-downloaded data has been added to ./iSHARC/workflow/dependencies/
#  anno_ref <- readRDS()

## fetch SCT normalized GEX matrix
expr <- GetAssayData(object = scMultiome, assay = "SCT", slot = "data")

### using ENCODE
expr_anno <- SingleR(test = expr, ref = anno_ref, labels = anno_ref$label.main, clusters =  Idents(scMultiome))

## match cluster labels and annotated labels
idx_m <- match(Idents(scMultiome), rownames(expr_anno))

## add labels scMultiome object
scMultiome[["WNN_SingleR_anno"]] <- expr_anno$labels[idx_m]
}

## umap
p1 <- DimPlot(scMultiome, reduction = "wnn.umap", group.by = "WNN_SingleR_anno",  label = TRUE, label.size = 2.5, repel = TRUE)  + ggtitle("")

## bar plot with WNN labels and singleR labels
dat  <- scMultiome[[c("seurat_clusters","WNN_SingleR_anno")]]
dat_sum <- dat %>%
           group_by(seurat_clusters, WNN_SingleR_anno) %>%
           summarise(cnt = n())
p2 <- ggplot(dat_sum, aes(fill = seurat_clusters, y = cnt, x = WNN_SingleR_anno))  
p2 <- p2 + geom_bar(position="stack", stat="identity")
p2 <- p2 + labs(y = "Number of cells", x = "SingleR annoated cell types")
p2 <- p2 + guides(fill=guide_legend(title="WNN clusters")) + theme_classic()

p1 + p2   & theme(plot.title = element_text(hjust = 0.5))

```

### Distinguish between tumor and normal cells
* umap labeled by tumor and normal
* assessment with inferCNV

To be added ...
